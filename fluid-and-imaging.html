<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Biostatistics for Fluid and Imaging Biomarkers</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs-2.29/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
    <link href="libs/tile-view-0.2.6/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view-0.2.6/tile-view.js"></script>
    <script src="libs/kePrint-0.0.1/kePrint.js"></script>
    <link href="libs/lightable-0.0.1/lightable.css" rel="stylesheet" />
    <link rel="stylesheet" href="css/styles.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">


class: middle, center

# Biostatistics for Fluid and Imaging Biomarkers

Michael Donohue, PhD

University of Southern California

### Biomarkers for Neurodegenerative Disorders

London, UK

May 2025


  




.pull-left[

&lt;img src="./images/atri.png" width="57%"  style="display: block; margin: auto;" /&gt;

]


.pull-right[

&lt;img src="./images/actc_logo.png" width="47%"  style="display: block; margin: auto;" /&gt;

]

---

# Course Overview

.large[
Topics:

- Hour 1 -- Biostatistics for Fluid and Imaging Biomarkers
- Hour 2 -- Modeling Longitudinal Data (Lars Racket)

Emphases:

- Visualization 
- Demonstrations using R, code available from:
  - [https://github.com/atri-biostats/biomarkers-neuro-disorders](https://github.com/atri-biostats/biomarkers-neuro-disorders)
]

---

# Session 1 Outline

.large[
- Batch Effects
- Experimental Design (Sample Randomization)
- Statistical Models for Assay Calibration/Quantification
- Classification (Supervised Learning)
  - Logistic Regression
  - Binary Trees
  - Random Forest
- Mixture Modeling (Unsupervised Learning)
  - Univariate
  - Bivariate
- Mixture of Experts (Unsupervised Learning with covariates)
- Reference Regions
- Harmonization using:
  - Centiloids
  - Empirical Cumulative Distribution Function (ECDF)
  - ComBat
]

---

class: inverse, middle, center

# Batch Effects

---

# Batch Effects: Boxplot



&lt;img src="fluid_imaging_fig/batch_data_plot-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

---

# Coefficient of Variation

.pull-left[

&lt;table class="table table-striped table-condensed" style="font-size: 18px; width: auto !important; margin-left: auto; margin-right: auto;"&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt; batch &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; N &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Mean &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; SD &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; SD/Mean = CV (%) &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 50 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 790 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 379 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 48 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; 2 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 50 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 925 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 299 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 32 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 50 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 725 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 389 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 54 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; 4 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 50 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 951 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 332 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 35 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; 5 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 50 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 690 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 312 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 45 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; 6 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 50 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 867 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 349 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 40 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; 7 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 50 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 837 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 446 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 53 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; 8 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 50 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 914 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 348 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 38 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; 9 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 50 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 883 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 271 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 31 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; 10 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 50 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 763 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 266 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 35 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;



]

.pull-right[

- Coefficient of Variation (CV) = SD/Mean
- Often used for quality control (reject batch with CV &gt; `\(x\)`)

]

---

# Testing for Batch Effects


``` r
anova(lm(Biomarker ~ batch, batch_data))
Analysis of Variance Table

Response: Biomarker
           Df   Sum Sq Mean Sq F value  Pr(&gt;F)    
batch       9  3573109  397012    3.37 0.00051 ***
Residuals 490 57758046  117874                    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
```

* Batch explains a significant amount of the variation in this simulated data
* R note: `batch` variable must be a `factor`, not `numeric` (otherwise, you will get a batch slope)

---

# Batch effects: Confounds

&lt;img src="fluid_imaging_fig/batch_confounds-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

???

Suppose we have groups of interest (say, active vs placebo) that we would like to compare.

Do we see an problem here?

---

# Randomized assignment of samples to plates

&lt;img src="fluid_imaging_fig/batch_randomized-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

???

If we have both groups represented in each batch, we can disentangle batch effects
and group effects

One way to ensure this, is to randomize samples to batches

---

# Experimental Design for Fluid Biomarkers

.large[
- Randomize samples to batches/plates
- Longitudinally collected samples (samples collected over time on same individual):
  - If batch effects are expected to be larger than storage effects, consider randomizing *individuals* to batches (i.e. keep all samples from individual on the same plate)
  - However, if storage effects are a concern, timely sample processing might be preferred.
- Randomization can be stratified to ensure important factors (e.g. treatment group, age, APOE `\(\epsilon4\)`) are balanced over batches.
]

---

# Sample Randomization

We use an `R` package [SRS](https://github.com/atrihub/SRS) ("Subject Randomization System"), which we have modified to deal with the constraints of plate capacity, and keeping samples from the same subject together.

(Note this is different than the `SRS` package on CRAN)



&lt;table class="table table-striped table-condensed" style="font-size: 18px; width: auto !important; margin-left: auto; margin-right: auto;"&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:right;"&gt; Subject ID &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; Num. of samples &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; Group &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; Age &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; Plate &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 5 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; old &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 11 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 2 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 5 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; old &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 3 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 5 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; old &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 6 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 4 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 5 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; young &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 4 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 5 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 5 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; old &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 8 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 6 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 4 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; young &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 10 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 7 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 5 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; young &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 2 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 8 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 4 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; old &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 1 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 9 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 4 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; young &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 9 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 10 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 5 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; old &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 12 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;



---

# Sample Randomization

.pull-left[

&lt;table class="table table-striped table-condensed" style="font-size: 18px; width: auto !important; margin-left: auto; margin-right: auto;"&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Plate &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 2 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 4 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 5 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 6 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 7 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 8 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 9 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 10 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 11 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 12 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 13 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; old &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 2 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 4 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 4 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 2 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 3 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; young &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 4 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 4 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 5 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 4 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 4 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 4 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Num. samples &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 27 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 27 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 27 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 29 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 29 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 30 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 30 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 27 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 30 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 29 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 27 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 27 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 30 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;



]

.pull-right[

- Number of young and old well balanced across the 13 plates
- Number of samples per plate is also reasonable (plate capacity was set at 30 samples)

]

---

class: inverse, middle, center

# Calibration

---

# Calibration

.large[

- Calibration: developing a map from "raw" assay responses to concentrations (ng/ml) using samples of *known* concentrations
- We will explore some approaches to calibration with methods from the `R` package `calibFit` (Haaland et al., 2011; Davidian et al., 1990)
- The package includes some example data:
  - High Performance Liquid Chromatography (HPLC) and 
  - Enzyme Linked Immunosorbent Assay (ELISA)
- These examples are taken straight from the package vignette

]

???

The package is not actively maintained, so you must install the package from the CRAN archive

---

# Calibration

.pull-leftWider[

&lt;img src="fluid_imaging_fig/calibFit_fits-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

]

.pull-rightNarrower[

- *Calibration* curves are estimated using assay responses (vertical axis) from samples of *known* concentration (horizontal axis)
- Curves are subsequently used to map assay responses to estimated concentration values.
- Both fits exhibit *heteroscedasticity*: the error variance is not constant with respect to Concentration
- Most models assume *homoscedasticity*, or constant error variance.

]

---

# Residuals (difference between response &amp; fitted values)

&lt;img src="fluid_imaging_fig/calibFit_residuals-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

---

# Typical Regression

Typically, regression models are of the form: 

`\begin{equation}
Y_{i}=f(x_i,\beta)+\epsilon_{i}, 
\end{equation}`

where:

- `\(Y_{i}\)` is the observed response/outcome for `\(i\)`th individual ( `\(i=1,\ldots,n\)` ) 
- `\(x_i\)` are covariates/predictors for `\(i\)`th individual
- `\(\beta\)` are regression coefficients to be estimated
- `\(f(\cdot,\cdot)\)` is the model (assumed "known" or to be estimated)
  - In linear regression `\(f(x_i,\beta)=x_i\beta\)`
- `\(\epsilon_i\)` is the residual error
- We assume `\(\epsilon\sim\mathcal{N}(0,\sigma^2)\)` 
- `\(\sigma\)` is the *constant* standard deviation (*homoscedastic*)

If the standard deviation is not actually constant (*heteroscedastic*), estimates might be unreliable.


---

## Ordinary Least Squares: minimizing the sum of squared residuals

&lt;video width="100%"  controls loop&gt;&lt;source src="fluid_imaging_fig/regression-movie.webm" /&gt;&lt;/video&gt;

`\(^*\)` RSS = Residual sum of squares, or `\(\sum_i (\textrm{Observed}_i-\textrm{Fitted}_i)^2\)`

---

# Modeling Heteroscedastic Errors

The `calibFit` package includes models of the form: 

`\begin{equation}
Y_{ij}=f(x_i,\beta)+\sigma g(\mu_i,z_i,\theta) \epsilon_{ij}, 
\end{equation}`

where,

- `\(Y_{ij}\)` are observed assay values/responses for `\(i\)`th individual ( `\(i=1,\ldots,n\)` ), `\(j\)`th replicate
- `\(g(\mu_i,z_i,\theta)\)` is a function that allows the variances to depend on:
  - `\(\mu_i\)` (the mean response `\(f(x_i,\beta)\)`), 
  - covariates `\(z_i\)`, and 
  - a parameter ("known" or unknown) `\(\theta\)`.
- `\(\epsilon_{ij}\sim\mathcal{N}(0,1)\)` 

In particular, `calibFit` implements the Power of the Mean (POM) function

`\begin{equation}
g(\mu_i,\theta) = \mu_i^{2\theta}
\end{equation}`

which results in 

`\begin{equation}
\operatorname{var}(Y_{ij}) = \sigma^2\mu_i^{2\theta}
\end{equation}`

???

allowing the variance to depend on the mean.

---

# "Homogenized" Residuals From Fits with POM



&lt;img src="fluid_imaging_fig/calibFit_pom_residuals-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

---

# HPLC Calibration With/Without POM Variance

&lt;img src="fluid_imaging_fig/calib_hplc_pom-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

???

The mean does not change much, but we get more accurate and tighter 95% confidence bands

---

# Elisa Calibration With/Without POM Variance

&lt;img src="fluid_imaging_fig/calib_elisa_pom-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

---

# Calibrated Estimates &amp; Minimum Detectable Concentration (MDC) for Each Sample

.pull-left[

&lt;img src="fluid_imaging_fig/calibrated1-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

]

.pull-right[

&lt;img src="fluid_imaging_fig/calibrated2-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

]

---

# Calibration Statistics

Assuming calibration curve `\(f\)`, mapping concentrations to assay responses, is increasing, we define the following terms.

**Minimum Detectable Concentration (MDC)**: The lowest concentration where the curve is increasing, or:

  `$$x_{\textrm{MDC}} = \min\{x : f(x, \beta) &gt; \textrm{UCL}_0\}$$`
  
  where `\(\textrm{UCL}_0\)` is the upper confidence limit at 0

**Reliable Detection Limit (RDL)**: The lowest concentration that has a high probability of producing a response that is significantly greater than the response at 0, or 
  
`$$x_{\textrm{RDL}} = \min\{x : \textrm{LCL}_x &gt; \textrm{UCL}_0 \}$$`

**Limit of Quantitization (LOQ)**: The lowest concentration at which the coefficient of variation is less than a fixed percent (default is 20% in the `calibFit` package).

---

class: inverse, middle, center

# Supervised Learning

## Classification

---

# Classification

.pull-leftWider[

&lt;img src="fluid_imaging_fig/classification-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

]

.pull-rightNarrower[

- Data from [adni.loni.usc.edu](adni.loni.usc.edu)
- CSF Abeta 1-42 and t-tau assayed using the automated Roche Elecsys and cobas e 601 immunoassay analyzer system
- Filter time points associated with first assay, and ignore subsequent time points
- We'll ignore MCI and focus on CN vs Dementia
- Values greater than the upper limit of detection have been assigned the limit

]

---

# Classification

&lt;img src="fluid_imaging_fig/classification_no_mci-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

---

# Reciever Operating Characteristic (ROC) Curves

.pull-left[

&lt;img src="fluid_imaging_fig/ROC_abeta-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

]

.pull-right[

For each potential threshold applied to CSF `\(\textrm{A}\beta 42\)`, 
we calculate:
- Sensitivity: True Positive Rate = TP/(TP+FN)
- Specificity: True Negative Rate = TN/(TN+FP)

This traces out the ROC curve.

A typical summary of a classifier's performance is the
Area Under the Curve (AUC)

AUC=0.83 in this case, with 95% CI ( 0.8, 0.86 )

AUCs close to one indicate good performance.

The threshold shown here maximizes the distance between the curve
and the diagonal line (chance) (Youden, 1950)

]

???

Sensitivity is a measure of how well we are detecting positive cases

Specificity is a measure of how well we are detecting controls or negative cases

Youden's index gives equal weight to false positives and false negatives (not necessarily appropriate)

---

# Same AUCs do not imply same performance 

.pull-left[

&lt;img src="fluid_imaging_fig/ROC_same-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

]

.pull-right[

AUC is a somewhat crude metric of classification accuracy.

AUC1 = AUC2 = 0.95 in this case, with 95% CI ( 0.94, 0.95 )

Both show good overall performance with AUC close to one.

However, one attains 80% sensitivity and 100% specificity, while the other attains the opposite (100% sensitivity and 80% specificity).

]

---

# Comparing ROC Curves

.pull-left[

&lt;img src="fluid_imaging_fig/ROC_abeta_tau-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

]

.pull-right[


| Marker                 | AUC                  | 95% CI                       | P-value `\(^*\)` |
| ---------------------- |:--------------------:| ----------------------------:| ------------:|
| `\(\textrm{A}\beta\)`      | 0.83    | 0.8, 0.86    |              |
| Tau                    | 0.78      | 0.75, 0.82      |  0.07        |
| Tau/ `\(\textrm{A}\beta\)` | 0.9 | 0.87, 0.92 |  &lt;0.001      |
`\(^*\)` Bootstrap test comparing each row to `\(\textrm{A}\beta\)` (Robin et al., 2011)

So the ratio of Tau / `\(\textrm{A}\beta\)` shows the best discrimination of NC from Dementia cases.



]

---

# Youden's Cutoff for Tau / `\(\textrm{A}\beta\)` Ratio

&lt;img src="fluid_imaging_fig/abeta_tau_scatter_youden-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

Line is Tau = 0.394 `\(\times\)` Abeta, depicting Youden's cutoff (maximizes sensitivity + specificity)

???

Youden's cutoff maximizing sensitivity + specificity is appropriate if sensitivity and specificity are equally important

---

# Logistic Regression



|Coefficient  | Estimate| Std. Error| z value|Pr(&gt;&amp;#124;z&amp;#124;) |
|:------------|--------:|----------:|-------:|:------------------|
|(Intercept)  |    -0.89|       0.13|    -6.7|&lt;0.001             |
|scale(ABETA) |    -1.59|       0.15|   -10.6|&lt;0.001             |
|scale(TAU)   |     1.26|       0.14|     9.0|&lt;0.001             |



`$$\log\big(\frac{p}{1-p}\big) = \hat\gamma_0 + A\beta_z \hat\gamma_{A\beta} + \textrm{tau}_z \hat\gamma_{\textrm{tau}}$$`
where `\(\hat\gamma\)` are regression coefficients.

---

# Logistic Regression Predicted Probabilities

&lt;img src="fluid_imaging_fig/logistic_pred_prob-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

???

line again depicts Youden's cutoff

---

# Ratio Contours

&lt;img src="fluid_imaging_fig/ratio_gradient-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

???

by using ratio's we're simplifying the bivariate scatter by assuming all dots along
these lines intersecting (0,0) are equivalent

dashed line has slope 1
---


# Logistic Regression Predicted Probability Contours

&lt;img src="fluid_imaging_fig/ratio_gradient_logistic-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

???

in contrast, logistic regression assumes the predicted probability gradient follows these
parallel lines

lines now are where predicted probabilities from logistic regression are constant

---

# Comparing ROC Curves

.pull-left[

&lt;img src="fluid_imaging_fig/ROC_logistic-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

]

.pull-right[


| Marker                 | AUC                      | 95% CI                           | P-value `\(^*\)` |
| ---------------------- |:------------------------:| --------------------------------:| ------------:|
| `\(\textrm{A}\beta\)`      | 0.83        | 0.8, 0.86        |              |
| Tau                    | 0.78          | 0.75, 0.82          |  0.07        |
| Tau/ `\(\textrm{A}\beta\)` | 0.9     | 0.87, 0.92     |  &lt;0.001      |
| Logisitic model        | 0.9 | 0.87, 0.92 |  &lt;0.001      |
`\(^*\)` Bootstrap test comparing each row to `\(\textrm{A}\beta\)` (Robin et al., 2011)

Logistic model ROC is very similar to Tau/ `\(\textrm{A}\beta\)` ratio ROC.



]

---

# Logistic Regression with Age and APOE



|Coefficient              | Estimate| Std. Error| z value|Pr(&gt;&amp;#124;z&amp;#124;) |
|:------------------------|--------:|----------:|-------:|:------------------|
|(Intercept)              |    -1.12|       0.17|    -6.5|&lt;0.001             |
|scale(ABETA)             |    -1.43|       0.16|    -9.0|&lt;0.001             |
|scale(TAU)               |     1.19|       0.14|     8.5|&lt;0.001             |
|scale(I(AGE + Years.bl)) |     0.14|       0.12|     1.2|0.230              |
|as.factor(APOE4)1        |     0.37|       0.25|     1.5|0.144              |
|as.factor(APOE4)2        |     1.26|       0.45|     2.8|0.005              |





This model does not provide much better ROC, either.

---

# Regression Trees

&lt;img src="fluid_imaging_fig/tree1-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

Hothorn et al. (2006)

???

Regression trees use recursive partitioning to classify data into more and more homogeneous subgroups

---

# Tree-based Methods

&lt;img src="fluid_imaging_fig/tree2-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

???

With this shallow tree, we end up with these four partitions of the Abeta-by-Tau scatter

---

# Comparing ROC Curves

.pull-left[

&lt;img src="fluid_imaging_fig/ROC_rf-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

]

.pull-right[


| Marker                 | AUC                      | 95% CI                           | P-value `\(^*\)` |
| ---------------------- |:------------------------:| --------------------------------:| ------------:|
| `\(\textrm{A}\beta\)`      | 0.83        | 0.8, 0.86        |              |
| Tau                    | 0.78          | 0.75, 0.82          |  0.07        |
| Tau/ `\(\textrm{A}\beta\)` | 0.9     | 0.87, 0.92     |  &lt;0.001      |
| Logisitic model        | 0.9 | 0.87, 0.92 |  &lt;0.001      |
| Binary Tree            | 0.88     | 0.86, 0.91     |  &lt;0.001      |
| Random Forest          | 0.95       | 0.93, 0.96       |  &lt;0.001      |
`\(^*\)` Bootstrap test comparing each row to `\(\textrm{A}\beta\)` (Robin et al., 2011)

Random Forests (Breiman, 2001; Hothorn et al., 2006) re-fit binary trees on random subsamples of the data, then aggregate resulting trees into a "forest". This results in smoother predictions and a smoother ROC curve.

* All three models should be (cross) validated, since they learn from known Dx.



]

---

class: inverse, middle, center

# Unsupervised Learning

## Mixture Modeling

---

# Unsupervised Learning

.large[
- The classification techniques we just reviewed can be thought of as *Supervised Learning* in which we attempt to learn known "labels" (CN, Dementia).
- *Mixture Modeling* is type of *Unsupervised Learning* technique in which we try to identify clusters of populations which appear to be arising from different distributions
- Don't confuse *Mixture Models* with *Mixed-Effects Models* (which we'll discuss later)
  - Think: "Mixture of Distributions"
]

---

# Distribution of ABETA

&lt;img src="fluid_imaging_fig/density_Abeta-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

- Distribution is bimodal
- Can we identify the two sub-distributions?
- We'll explore with `mixtools` package (Benaglia et al., 2009)

---

# Distribution of ABETA



&lt;img src="fluid_imaging_fig/mixture_distribution_Abeta-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

???

mixture models provide latent class membership probabilities, such as these 

---

# Posterior Membership Probabilities



| Abeta| Prob. Abnormal| Prob. Normal|
|-----:|--------------:|------------:|
|  1033|           0.58|         0.42|
|  1036|           0.57|         0.43|
|  1044|           0.53|         0.47|
|  1048|           0.52|         0.48|
|  1061|           0.46|         0.54|
|  1071|           0.42|         0.58|
|  1071|           0.42|         0.58|
|  1072|           0.41|         0.59|



---

## Bivariate Density



&lt;iframe src="bvdensity_csf_tau.html" width="100%" height="500" id="igraph" scrolling="no" seamless="seamless" frameBorder="0"&gt; &lt;/iframe&gt;

---

# Bivariate Density Contour Plot

&lt;img src="fluid_imaging_fig/bv_kernel_density-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

---

# Bivariate Mixture Model Posterior Probabilities

.pull-left[
&lt;img src="fluid_imaging_fig/mvmix_post_prob-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;
]
.pull-right[
&lt;img src="fluid_imaging_fig/mvmix_density-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;
]

???

line on the left is still Youden's cutoff for the ratio

Contours are confidence ellipses at 99%, 95%, and 90% just to help see the shape of the estimated distributions

---

# Mixture of Experts (unsupervised learning with covariates)

&lt;img src="./images/moe.png" width="60%"  style="display: block; margin: auto;" /&gt;

Murphy et al. (2020); Murphy and Murphy (2022)

---

# Mixture of Experts (unsupervised learning with covariates)

&lt;img src="fluid_imaging_fig/unnamed-chunk-15-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

MAP = maximum a posteriori classification

---

# Summary of considerations for fluid biomarkers

.large[
- Batch Effects
- Experimental Design (Sample Randomization)
- Statistical Models for Assay Calibration/Quantification
- Classification (Supervised Learning)
  - Logistic Regression
  - Binary Trees
  - Random Forest
- Mixture Modeling (Unsupervised Learning)
  - Univariate
  - Bivariate
  - With covariates (Mixture of Experts)
]

---

class: inverse, middle, center

# Imaging: Reference Regions

---

# Reference Regions

.large[
A common issue with statistical analyses of numeric summaries derived from imaging data is normalization to a reference region. 

Examples:

- Volumetric MRI: regional (e.g. hippocampal) volume relative to Intra-Cranial Volume (ICV)
- Amyloid PET: cortical-to-cerebellum Standardized Uptake Value Ratio (SUVr)

(Also an issue in non-imaging data, e.g. ratio of CSF `\(\textrm{A}\beta_{1-42}\)` to `\(\textrm{A}\beta_{1-40}\)`)
]

---

# Beware the "Ratio Fallacy" and "Spurious Correlation"
.large[
&gt; Spurious correlation refers to the correlation between indices that have a common component. A 'per ratio' standard is based on a biological measurement adjusted for some physical measurement by division. Renowned statisticians and biologists (Pearson, Neyman and Tanner) have warned about the problems in interpretation that ratios cause. This warning has been largely ignored. The consequences of using a single ratio as either the dependent or one of the independent variables in a multiple-regression analysis are described. It is shown that the use of ratios in regression analyses can lead to incorrect or misleading inferences. A recommendation is made that the use of ratios in regression analyses be avoided.

Kronmal (1993) "Spurious correlation and the fallacy of the ratio standard revisited". *Journal of the Royal Statistical Society: Series A*.

Examples abound: %ICV, SUVR, BMI, ...
]

---

# Ratio as Dependent Variable in Regression




``` r
lm_fit1_sex &lt;- lm(I(Hippocampus/ICV*100) ~ Sex, data=dd2)
```



|Coefficient | Estimate| Std. Error| t value|Pr(&gt;&amp;#124;t&amp;#124;) |
|:-----------|--------:|----------:|-------:|:------------------|
|(Intercept) |     0.49|          0|   150.8|&lt;0.001             |
|SexFemale   |     0.04|          0|     9.3|&lt;0.001             |



- Signficant association between Sex and Hippocampal Volume (%ICV)!
- (This linear model is essential just a two-sample t-test)
- Model fit to ADNI CN

---

# ICV as Covariate Instead of Denominator


``` r
lm_fit2_sex &lt;- lm(Hippocampus ~ ICV + Sex, data=dd2)
```



|Coefficient | Estimate| Std. Error| t value|Pr(&gt;&amp;#124;t&amp;#124;) |
|:-----------|--------:|----------:|-------:|:------------------|
|(Intercept) |     4389|        361|   12.16|&lt;0.001             |
|ICV         |        0|          0|    9.23|&lt;0.001             |
|SexFemale   |       34|         72|    0.47|0.64               |



- No association between Sex and Hippocampal Volume ( `\(\text{mm}^3\)` )!
- The **spurious association** in first model is driven by denominator (ICV), not numerator (hippocampal volume)

---

# Hippocampus vs ICV and Sex

.pull-leftWider[
&lt;img src="fluid_imaging_fig/hipp_sex_scatter-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;
]

.pull-rightNarrower[

- For a given ICV, there is not much difference between sexes
- These linear fits are more flexible than model above (two slopes for ICV vs one)

]

---

# Hippocampal volume ( `\(\textrm{mm}^3\)`, %ICV, and model-adjusted)

&lt;img src="fluid_imaging_fig/hipp_sex_box-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

---

# Hippocampal volume ( `\(\textrm{mm}^3\)`, %ICV, and model-adjusted)

.pull-leftWider[

&lt;img src="fluid_imaging_fig/hipp_adj_sex_scatter-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

]

.pull-rightNarrower[

- Model: 
.small[
`\(Y_i=\beta_0 + \beta_{\textrm{ICV}}\textrm{ICV}_i  + \beta_{\textrm{Male}}\textrm{Male}_i + \varepsilon_i\)`
]
- Adjusted volume: `\(Y_i - \hat{\beta}_{\textrm{ICV}}\textrm{ICV}_i\)` 
- Adjustment removes slope for ICV

]

---

class: inverse, middle, center

# Centiloids

---

# Centiloids

.large[

- Centiloids have become the industry standard standardized measure of amyloid PET (Klunk et al., 2015)
- Helpful in multi-site studies where different amyloid PET tracers might be utilized.
- What is a centiloid?

]

---

# What is a centiloid? Step 1: PiB SUVr to CL

.large[

- The original/base PiB SUVr to centiloid map:
- 1.009 PiB SUVr (mean in young controls) `\(\rightarrow\)` 0 CL
- 2.076 PiB SUVr (mean in AD cases) `\(\rightarrow\)` 100 CL
- For other PiB SUVr values, draw the line from (1.009 SUVr, 0 CL) to (2.076 SUVr, 100 CL)
- CL = 100 `\(\times\)` (PiB SUVr - 1.009)/1.067 (Klunk et al., 2015)

]

---

# What is a centiloid? Step 1: PiB SUVr to CL

&lt;img src="fluid_imaging_fig/unnamed-chunk-21-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

---

# What is a centiloid? Step 2: Other SUVr to PiB SUVr

.large[

- Step 2 requires *paired* data: each individuals scanned with PiB and the other tracer
- Linear regression (ordinary least squares) is used to create linear transformation
- Transformed data is then mapped to CL using map on prior slide

]

---

# What is a centiloid? Step 2: Other SUVr to PiB SUVr

&lt;img src="./images/rowe2017.png" width="75%"  style="display: block; margin: auto;" /&gt;

`\(\textrm{SUVR}_{\textrm{FBB}} = 0.61 \times  \textrm{SUVR}_{\textrm{PiB}} + 0.39\)`

Rowe et al. (2017)

---

# Distribution mapping

&lt;img src="./images/properzi2019.png" width="75%"  style="display: block; margin: auto;" /&gt;

Properzi et al. (2019)

???

Another approach to normalizing data from different tracers (or fluid assays for that matter) is to map distributions.

If we only have unpaired data from similar populations, we can map one to other under the assumption that their distributions should have similar shape.

---

# Emprical Cumulative Distribution Function (ECDF)

&lt;img src="fluid_imaging_fig/unnamed-chunk-24-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

???

CDFs are useful one-to-one maps

Underlie random number generators. A random number from a uniform 0-1 distribution can be mapped to any other distribution by the inverse CDF.

In this case we can map PiB SUVRs to florbetapir SUVRs or vice versa

But it only works if samples are similar, and we believe both tracers would sort the samples similarly.

---

# Weighted ECDFs to correct for sampling differences

N (%) per diagnosis and tracer:



|         |PiB        |Florbetapir |
|:--------|:----------|:-----------|
|CN       |20 (21.5%) |498 (38.5%) |
|MCI      |49 (52.7%) |588 (45.4%) |
|Dementia |24 (25.8%) |209 (16.1%) |



Inverse proportion weights:



|         | PiB| Florbetapir|
|:--------|---:|-----------:|
|CN       | 4.7|         2.6|
|MCI      | 1.9|         2.2|
|Dementia | 3.9|         6.2|



???

similar methodology underlies CDC growth charts that provide height and weight 
percentiles per age 

---

# Weighted ECDFs to correct for sample differences


``` r
# Record the sampling adjustment weights in the data
dd &lt;- dd %&gt;% mutate(
  wt = case_when(
    DX == 'CN' &amp; Tracer == 'PiB' ~ invproptab['CN', 'PiB'],
    DX == 'MCI' &amp; Tracer == 'PiB' ~ invproptab['MCI', 'PiB'],
    DX == 'Dementia' &amp; Tracer == 'PiB' ~ invproptab['Dementia', 'PiB'],
    DX == 'CN' &amp; Tracer == 'Florbetapir' ~ invproptab['CN', 'Florbetapir'],
    DX == 'MCI' &amp; Tracer == 'Florbetapir' ~ invproptab['MCI', 'Florbetapir'],
    DX == 'Dementia' &amp; Tracer == 'Florbetapir' ~ invproptab['Dementia', 'Florbetapir']
  ))
```

---

# Weighted ECDFs to correct for sample differences




``` r
# Create adjusted ECDF functions (mapping SUVRs to Cumulative Probabilities)
# Hmisc::wtd.Ecdf returns a data.frame evaluating the ECDF at each observed value
PiB.ecdf &lt;- with(subset(dd, Tracer == 'PiB'), ecdf.func(SUVR, weights=wt))
Fbp.ecdf &lt;- with(subset(dd, Tracer == 'Florbetapir'), ecdf.func(SUVR, weights=wt))

# Create adjusted **inverse** ECDF functions 
# mapping Cumulative Probabilities (0 to 1 scale) to SUVRs
PiB.inv.ecdf &lt;- with(subset(dd, Tracer == 'PiB'), 
 inv.ecdf(SUVR, weights=wt))
Fbp.inv.ecdf &lt;- with(subset(dd, Tracer == 'Florbetapir'),  
 inv.ecdf(SUVR, weights=wt))
```

---

# Weighted ECDFs to correct for sample differences


``` r
dd &lt;- dd %&gt;% mutate(
  `Adjusted cumulative probability` = case_when( # 
    Tracer == 'PiB' ~ PiB.ecdf(SUVR),
    Tracer == 'Florbetapir' ~ Fbp.ecdf(SUVR)),
  `Adjusted Z-score` = qnorm(`Adjusted cumulative probability`), # adjusted z-scores
  `Florbetapir to PiB adjusted SUVR` = case_when(
    Tracer == 'Florbetapir' ~ PiB.inv.ecdf(Fbp.ecdf(SUVR))),
  `PiB to Florbetapir adjusted SUVR` = case_when(
    Tracer == 'PiB' ~ Fbp.inv.ecdf(PiB.ecdf(SUVR))),
  CL = case_when(
    Tracer == 'PiB' ~ 100*(SUVR - 1.009)/1.067)) %&gt;%
  arrange(Tracer, SUVR)
```

---

# Weighted ECDFs to correct for sample differences

&lt;img src="fluid_imaging_fig/weighted-ecdfs-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

* solid line is un-adjusted ECDF; dashed line is ECDF adjusted for sample differences

---

# Centiloids vs ADNI Adjusted Percentiles

&lt;img src="fluid_imaging_fig/unnamed-chunk-31-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

---

# Densities for estimated and actual PiB SUVRs

&lt;img src="fluid_imaging_fig/pib-densities-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

???

Not perfectly matched due to different sample characteristics. To be expected.

Recall PiB had less representation of CU and Florbetapir had more with dementia

---

# Densities by diagnosis

&lt;img src="fluid_imaging_fig/pib-densities-dx-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

---

# Densities for weighted ECDF derived z-scores

&lt;img src="fluid_imaging_fig/z-score-densities-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

Useful for analysis, as in Li et al. (2019)

???

Useful for analysis

---

# Using the ECDF derived z-scores for analysis

.pull-left[

&lt;img src="./images/li2019.png" width="95%"  style="display: block; margin: auto;" /&gt;

]

.pull-right[

* ECDF derived z-scores were used in model (assuming Gaussian residuals)
* Posterior estimates (on z-score scale) then back transformed to cumulative probabilities
* Natural interpretation:
  * 0 (most healthy) to 1 (most severe) 
  * Comparable across different measures

(Li et al., 2019)

]

---

# Validation on a holdout set with both tracers (FBB `\(\rightarrow\)` PiB)

&lt;img src="fluid_imaging_fig/unnamed-chunk-33-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

`\(^*\)` Using PiB = (Florbetapir - 0.502)/0.536 from Navitsky et al. (2018)

???

We held out a random sample of 10 participants with both PiB and FBB

Note that the linear mapping from Navitsky is estimating PiB values outside of 
the observed range of actual PiB values (near 0.75). 

This will never happen with ECDF mapping.

---

# Validation on a holdout set with both tracers (PiB `\(\rightarrow\)` FBB)

&lt;img src="fluid_imaging_fig/unnamed-chunk-34-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

`\(^*\)` Using Florbetapir = PiB `\(\times\)` 0.536 + 0.502 from Navitsky et al. (2018)

???

This type of approach could also be useful for standardizing fluid assays

---

# Validation on a holdout set with both tracers (FBB `\(\rightarrow\)` PiB)

&lt;img src="fluid_imaging_fig/unnamed-chunk-35-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

`\(^*\)` Using PiB = (Florbetapir - 0.503)/0.497 from Royse et al. (2021)

???

---

# Validation on a holdout set with both tracers (PiB `\(\rightarrow\)` FBB)

&lt;img src="fluid_imaging_fig/unnamed-chunk-36-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

`\(^*\)` Using Florbetapir = PiB `\(\times\)` 0.497 + 0.503 from Royse et al. (2021)

???

dashed line is FBP threshold of 1.11

---

# Where is linear map struggling?

.pull-left[

&lt;img src="./images/Royse_2021_Fig2.png" width="80%"  style="display: block; margin: auto;" /&gt;

]

.pull-right[

&lt;img src="./images/Royse_2021_Fig2_zoom.png" width="70%"  style="display: block; margin: auto;" /&gt;

]

From Royse et al. (2021)

---

# ComBat Step 1: Estimate effect of tracer on mean &amp; variance





Outcome is (natural) `\(\log(\textrm{SUVR})\)`


```
                Value Std.Error        DF t-value p-value    
(Intercept) -3.81e-02  3.31e-02  2.06e+03   -1.15   0.249    
TracerAV45  -3.34e-01  9.98e-03  2.06e+03  -33.43 &lt; 2e-16 ***
TracerFBB   -3.32e-01  1.27e-02  2.06e+03  -26.07 &lt; 2e-16 ***
APOE41       1.56e-01  8.52e-03  1.72e+03   18.29 &lt; 2e-16 ***
APOE42       2.43e-01  1.51e-02  1.72e+03   16.13 &lt; 2e-16 ***
DXMCI        1.39e-02  4.23e-03  2.06e+03    3.30   0.001 ***
DXDementia   3.75e-02  6.45e-03  2.06e+03    5.81 7.3e-09 ***
Age          6.29e-03  3.30e-04  2.06e+03   19.06 &lt; 2e-16 ***
MMSE        -3.23e-04  5.74e-04  2.06e+03   -0.56   0.573    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
```

Johnson et al. (2007); Beer et al. (2020)

---

# ComBat Step 1: Estimate effect of tracer on mean &amp; variance


```
Random effects:
 Formula: ~1 | RID
        (Intercept) Residual
StdDev:       3.187        1

Variance function:
 Structure: Different standard deviations per stratum
 Formula: ~1 | Tracer 
 Parameter estimates:
AV45  PIB  FBB 
1.00 1.97 0.64 
```

---

# ComBat Step 2: Get fitted values and prediction assuming PiB


``` r
dd.combat$fitted_log.SUVR &lt;- predict(combat.fit) %&gt;% as.numeric()

dd.combat$pred_log.SUVR_PiB &lt;- predict(combat.fit, 
  newdata = dd.combat %&gt;% mutate(Tracer = "PIB")) %&gt;% as.numeric()
```

---

# ComBat Step 3: Get residuals, and rescale them to PiB scale


``` r
(sdWeights &lt;- coef(combat.fit$modelStruct$varStruct, unconstrained = FALSE))
 PIB  FBB 
1.97 0.64 
dd.combat &lt;- dd.combat %&gt;% 
  mutate(
    resids = log.SUVR - fitted_log.SUVR,
    homog_resids = case_when(
      Tracer == 'PIB' ~ resids,
      Tracer == 'AV45' ~ resids * sdWeights['PIB'] ,
      Tracer == 'FBB' ~ resids * sdWeights['PIB'] / sdWeights['FBB']),
    ComBat_log.SUVR_PiB = homog_resids + pred_log.SUVR_PiB,
    fitted_SUVR = exp(fitted_log.SUVR),
    ComBat_SUVR_PiB = exp(ComBat_log.SUVR_PiB))
```

ComBat is the sum of predicted values and residuals "homogenized" to PiB


```
# A tibble: 3 × 3
  Tracer `SD of homog_resids` `SD of resids`
  &lt;fct&gt;                 &lt;dbl&gt;          &lt;dbl&gt;
1 PIB                  0.0839         0.0839
2 AV45                 0.0757         0.0384
3 FBB                  0.0574         0.0185
```

---

# ComBat results

&lt;img src="fluid_imaging_fig/unnamed-chunk-44-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

---

# ComBat results

&lt;img src="fluid_imaging_fig/unnamed-chunk-45-1.svg" width="100%"  style="display: block; margin: auto;" /&gt;

---

# Summary of considerations for imaging data

.large[

* Avoid using ratios whenever possible. Better to include "denominators" as covariates in regression models.
* The Empirical Cumulative Distribution Function (ECDF) is a useful non-parametric tool for standardization.
  * Can handle non-linear relationships
  * Percentiles are intuitive and familiar
  * ECDF derived maps will not produce out-of-range estimates
  * Percentiles can be mapped to standard normal `\(z\)`-scores to facilitate modelling

]



---

class: inverse, middle, center

# Thank you!

---

# References (1/3)

Beer, J. C., N. J. Tustison, P. A. Cook, C. Davatzikos, Y. I. Sheline,
R. T. Shinohara, K. A. Linn, Alzheimer’s Disease Neuroimaging
Initiative, and others (2020). "Longitudinal ComBat: A method for
harmonizing longitudinal multi-scanner imaging data". In: _Neuroimage_
220, p. 117129.

Benaglia, T., D. Chauveau, D. R. Hunter, and D. Young (2009).
"mixtools: An R Package for Analyzing Finite Mixture Models". In:
_Journal of Statistical Software_ 32.6, pp. 1-29. URL:
[http://www.jstatsoft.org/v32/i06/](http://www.jstatsoft.org/v32/i06/).

Breiman, L. (2001). "Random forests". In: _Machine learning_ 45.1, pp.
5-32.

Davidian, M. and P. D. Haaland (1990). "Regression and calibration with
nonconstant error variance". In: _Chemometrics and Intelligent
Laboratory Systems_ 9.3, pp. 231-248.

Haaland, P., D. Samarov, and E. McVey (2011). _calibFit: Statistical
models and tools for assay calibration_. R package version 2.1.0. URL:
[https://CRAN.R-project.org/package=calibFit](https://CRAN.R-project.org/package=calibFit).

Hothorn, T., P. Buehlmann, S. Dudoit, A. Molinaro, and M. Van Der Laan
(2006). "Survival Ensembles". In: _Biostatistics_ 7.3, pp. 355-373.

Hothorn, T., K. Hornik, and A. Zeileis (2006). "Unbiased Recursive
Partitioning: A Conditional Inference Framework". In: _Journal of
Computational and Graphical Statistics_ 15.3, pp. 651-674.

---

# References (2/3)

Johnson, W. E. et al. (2007). "Adjusting batch effects in microarray
expression data using empirical Bayes methods". In: _Biostatistics_
8.1, pp. 118-127.

Klunk, W. E. et al. (2015). "The Centiloid Project: standardizing
quantitative amyloid plaque estimation by PET". In: _Alzheimer's &amp;
dementia_ 11.1, pp. 1-15.

Kronmal, R. A. (1993). "Spurious correlation and the fallacy of the
ratio standard revisited". In: _Journal of the Royal Statistical
Society: Series A (Statistics in Society)_ 156.3, pp. 379-392.

Li, D. et al. (2019). "Bayesian latent time joint mixed effect models
for multicohort longitudinal data". In: _Statistical methods in medical
research_ 28.3, pp. 835-845.

Murphy, K. et al. (2020). "Gaussian Parsimonious Clustering Models with
Covariates and a Noise Component". In: _Advances in Data Analysis and
Classification_ 14.2, pp. 293-325. DOI:
[10.1007/s11634-019-00373-8](https://doi.org/10.1007%2Fs11634-019-00373-8).
URL:
[https://doi.org/10.1007/s11634-019-00373-8](https://doi.org/10.1007/s11634-019-00373-8).

Murphy, K. et al. (2022). _\texttt\textupMoEClust: Gaussian
Parsimonious Clustering Models with Covariates and a Noise Component_.
\textsfR package version 1.5.0. URL:
[https://cran.r-project.org/package=MoEClust](https://cran.r-project.org/package=MoEClust).

---

# References (3/3)

Murphy, K. et al. (2020). "Gaussian Parsimonious Clustering Models with
Covariates and a Noise Component". In: _Advances in Data Analysis and
Classification_ 14.2, pp. 293-325. DOI:
[10.1007/s11634-019-00373-8](https://doi.org/10.1007%2Fs11634-019-00373-8).
URL:
[https://doi.org/10.1007/s11634-019-00373-8](https://doi.org/10.1007/s11634-019-00373-8).

Navitsky, M. et al. (2018). "Standardization of amyloid quantitation
with florbetapir standardized uptake value ratios to the Centiloid
scale". In: _Alzheimer's &amp; Dementia_ 14.12, pp. 1565-1571.

Properzi, M. J. et al. (2019). "Nonlinear Distributional Mapping
(NoDiM) for harmonization across amyloid-PET radiotracers". In:
_Neuroimage_ 186, pp. 446-454.

Robin, X. et al. (2011). "pROC: an open-source package for R and S+ to
analyze and compare ROC curves". In: _BMC Bioinformatics_ 12, p. 77.

Rowe, C. C. et al. (2017). "18 F-Florbetaben PET beta-amyloid binding
expressed in Centiloids". In: _European journal of nuclear medicine and
molecular imaging_ 44.12, pp. 2053-2059.

Royse, S. K. et al. (2021). "Validation of amyloid PET positivity
thresholds in centiloids: a multisite PET study approach". In:
_Alzheimer's Research &amp; Therapy_ 13.1, pp. 1-10.

Youden, W. J. (1950). "Index for rating diagnostic tests". In: _Cancer_
3.1, pp. 32-35.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
  "highlightStyle": "solarized-light",
  "highlightLanguage": ["r", "css", "yaml"],
  "highlightLines": true,
  "countIncrementalSlides": false,
  "ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
